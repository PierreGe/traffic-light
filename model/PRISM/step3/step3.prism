ctmc



module Controller
	[change] true -> 1/3.0 : true;
endmodule

module TrafficLightLeftRight
	// 0 : Red / 1 : Green / 2 : Crosswalk / 3: Bus
	LRcolor : [0..3] init 0;
	LRprec : bool init false;
	LRbusc : bool init false;
	LRpreemptible : bool init true;
	LRpedc : bool init false;

	[change] LRcolor = 0 -> (LRcolor' = 1); // Red cahnge
	[change] LRcolor = 1 -> (LRcolor' = 0); // Green change
	[change] LRcolor = 2 & FBcolor = 1 -> (LRcolor' = 2) & (LRprec'=false); // CW FB green->Red
	[change] LRcolor=2 & FBcolor=2 & CWstate=1 -> (LRcolor'=2); // CW CWleave Green
	[change] LRcolor = 3 & FBcolor = 1 -> (LRcolor' = 3) & (LRprec'=false); // Bus FB green->Red
	[change] LRcolor=3 & FBcolor=3 & BUSstate=1 -> (LRcolor'=3); // Bus BUS leave Green
	[change] LRcolor=3 & FBcolor=3 & BUSstate=2 & CWstate=7 -> (LRcolor'=3); // Bus BUS leave Called
	

	[pedCall] LRcolor = 0 & !LRbusc -> (LRcolor' = 2) & (LRprec' = true) & (LRpedc'=true); // Red ped call
	[pedCall] LRcolor = 1 & FBcolor = 0 & !LRbusc-> (LRcolor' = 1) & (LRpedc'=true); // Green Pedcall on other light
	[pedCall] LRcolor = 2 & FBcolor = 0 & !LRbusc-> (LRcolor' = 2) & (LRpedc'=true); // CW pedcall on other light
	[pedCall] LRcolor = 1 & FBcolor = 0 & LRbusc -> (LRcolor' = 1) & (LRpedc'=true) & (LRpreemptible'=false); // Green Pedcall on other light
	[pedCall] LRcolor = 2 & FBcolor = 0 & LRbusc -> (LRcolor' = 2) & (LRpedc'=true) & (LRpreemptible'=false); // CW pedcall on other light	

	[delayedPedCall] true -> (LRpedc'=true); // Delayed pedcall

	[busCall] LRcolor = 0 -> (LRcolor' = 3) & (LRprec' = true) & (LRbusc'=true); // Red buscall
	[busCall] LRcolor = 1 & FBcolor = 0 -> (LRcolor' =1) & (LRbusc'=true); // Green Buscall on other light
	[busCall] LRcolor = 2 & LRpreemptible -> (LRcolor' = 3) & (LRbusc'=true); // CW buscall
	[busCall] LRcolor = 3 & FBcolor = 0 -> (LRcolor' = 3) & (LRbusc'=true); // Bus buscall on other light
	[busCall] FBcolor = 3 & LRcolor = 3 & BUSstate = 3 & CWstate = 7 -> (LRcolor'=3); // Bus BUS waiting to green

	[delayedBusCall] true -> (LRbusc'=true);

	[free] LRcolor = 2 & !LRbusc & LRprec -> (LRcolor' = 0) & (LRpedc'=false) & (LRpreemptible'=true); // CW free
	[free] LRcolor = 2 & !LRbusc & !LRprec -> (LRcolor' = 1) & (LRpedc'=false) & (LRpreemptible'=true); // CW free
	[free] LRcolor = 2 & LRbusc -> (LRcolor' = 3) & (LRpedc'=false); // CW free
	[free] LRcolor = 3 & LRpedc -> (LRcolor' = 2) & (LRpreemptible'=true) & (LRbusc'=false); // Bus free
	[free] LRcolor = 3 & !LRpedc & LRprec -> (LRcolor' =0) & (LRpreemptible'=true) & (LRbusc'=false); // Bus free
	[free] LRcolor = 3 & !LRpedc & !LRprec -> (LRcolor'= 1) & (LRpreemptible'=true) & (LRbusc'=false); // Bus free

	
endmodule

module TrafficLightFrontBack
	// 0: Red / 1 : Green / 2 : Crosswalk // 3: Bus
	FBcolor : [0..3] init 1;
	FBprec : bool init false;
	FBbusc : bool init false;
	FBpreemptible : bool init true;
	FBpedc : bool init false;
	

	[change] FBcolor = 0 -> (FBcolor' = 1); // Red change
	[change] FBcolor = 1 -> (FBcolor' = 0); // Green change
	[change] FBcolor = 2 & LRcolor = 1 -> (FBcolor' = 2) & (FBprec'=false); // CW LR green->Red
	[change] LRcolor=2 & FBcolor=2 & CWstate=1 -> (FBcolor'=2); // CW CWleave Green
	[change] FBcolor = 3 & LRcolor = 1 -> (FBcolor' = 3) & (FBprec'=false); // Bus LR green->red
	[change] LRcolor=3 & FBcolor=3 & BUSstate=1 -> (FBcolor'=3); // Bus BUS leave Green
	[change] LRcolor=3 & FBcolor=3 & BUSstate=2 & CWstate=7 -> (FBcolor'=3); // Bus BUS leave Called

	[pedCall] FBcolor = 0 & !FBbusc -> (FBcolor' = 2) & (FBprec'=true) & (FBpedc'=true); // Red pedcall
	[pedCall] FBcolor = 1 & LRcolor = 0 -> (FBcolor' = 1) & (FBpedc'=true); // Green pedcall on other light
	[pedCall] FBcolor = 2 & LRcolor = 0 -> (FBcolor' = 2) & (FBpedc'=true); // CW pedCall on other light

	[delayedPedCall] true -> (FBpedc'=true); // ALL -> Delayed pedcall

	[busCall] FBcolor = 0 -> (FBcolor' = 3) & (FBprec' = true) & (FBbusc'=true); // Red buscall
	[busCall] FBcolor = 1 & LRcolor = 0 -> (FBcolor' =1) & (FBbusc'=true); // Green Buscall on other light
	[busCall] FBcolor = 2 & FBpreemptible -> (FBcolor' = 3) & (FBbusc'=true); // CW buscall
	[busCall] FBcolor = 3 & LRcolor = 0 -> (FBcolor' = 3) & (FBbusc'=true); // Bus buscall on other light
	[busCall] FBcolor = 3 & LRcolor = 3 & BUSstate = 3 & CWstate = 7 -> (FBcolor'=3); // Bus BUS waiting to green

	[delayedBusCall] true -> (FBbusc'=true); // ALL -> Delayed buscall	

	[free] FBcolor = 2 & !FBbusc & FBprec -> (FBcolor' = 0) &( FBpedc'=false) & (FBpreemptible'=true); // CW free
	[free] FBcolor = 2 & !FBbusc & !FBprec -> (FBcolor' = 1) & (FBpedc'=false) & (FBpreemptible'=true); // CW free
	[free] FBcolor = 2 & FBbusc -> (FBcolor' = 3) & (FBpedc'=false); // CW free
	[free] FBcolor = 3 & FBpedc -> (FBcolor' = 2) & (FBpreemptible'=true) & (FBbusc'=false); // Bus free
	[free] FBcolor = 3 & !FBpedc & FBprec -> (FBcolor' = 0) & (FBpreemptible'=true) & (FBbusc'=false); // Bus free
	[free] FBcolor = 3 & !FBpedc & !FBprec -> (FBcolor' = 1) & (FBpreemptible'=true) & (FBbusc'=false); // Bus free

	
endmodule


const double CWtime;

module crosswalk
	// 0 : Red / 1 : Green / 2 : Called / 3 : Waiting / 4 : Free / 5 : DelayedCall / 6 : Return
	// 7 : Preempted / 8: Bus
	CWstate : [0..8] init 0;
	CWjustCalled : bool init false;
	CWbusc : bool init false;
	CWpedc : bool init false;
	CWpreemptible : bool init true;

	[change] CWstate = 0 -> (CWjustCalled' = false); // Red  FB LR change
	[change] CWstate = 2 -> (CWstate'=3); // Called change
	[change] CWstate = 5 -> (CWstate'=6); // DelayedCall change
	[change] CWstate = 1 -> (CWstate'=4); // Green change
	[change] BUSstate=2 & CWstate=7 -> (CWstate'=7); // Preempted BUS leave Called
	[change] CWstate = 7 & BUSstate=1 -> (CWstate'=7); // Preempted BUS leave Called

	[delayedPedCall] CWstate = 0 & CWjustCalled & !CWbusc -> 1/CWtime : (CWstate'=5) & (CWpedc'=true); // Red delayedCall
	[pedCall] CWstate = 0 & !CWjustCalled & !CWbusc -> 1/CWtime : (CWstate'=2) & (CWpedc'=true); // Red pedcall
	[pedCall] CWstate = 0 & CWbusc -> 1/CWtime : (CWstate'=7) & (CWpedc'=true) & (CWpreemptible'=false); // Red pedcall
	[pedCall] CWstate = 6 -> (CWstate'=2); // Return pedCall
	[pedCall] CWstate = 3 -> (CWstate'=1); // Waiting pedCall

	[busCall] CWstate = 2 -> (CWstate'=7); // Called busCall
	[busCall] CWstate = 6 -> (CWstate'=7); // Return busCall
	[busCall] CWstate = 3 -> (CWstate'=7); // waiting buscall
	[busCall] CWstate = 0 -> (CWstate'=0); // Red buscall
	[busCall] CWstate = 7 -> (CWstate'=7); // Preempted BUS waiting to green


	[free] CWstate = 7 -> (CWstate'=1); // Preempted free
	[free] CWstate = 4 & !CWbusc -> (CWstate'=0) & (CWpedc'=false) & (CWpreemptible'=true) & (CWjustCalled'=true); // Free free
	[free] CWstate = 4 & CWbusc -> (CWstate'=8) & (CWpedc'=false); // Free free
	[free] CWstate = 8 -> (CWstate'=0) & (CWpreemptible'=true) & (CWjustCalled'=true); // Bus free
	[free] CWstate = 0 -> (CWstate'=0); // Red free

endmodule

const double BUStime;

module bus
	// 0 : Red / 1 : Green / 2: Called / 3: Waiting / 4: Free / 5 : DelayedCall / 6: Return
	// 7: Preempted /  8 : Crosswalk
	BUSstate : [0..8] init 0;
	BUSjustCalled : bool init false;
	BUSbusc : bool init false;
	BUSpedc : bool init false;
	BUSpreemptible : bool init true;

	[change] BUSstate = 0 -> (BUSjustCalled'=false); // Red FB LR change
	[change] BUSstate = 2 -> (BUSstate'=3); // Called change
	[change] BUSstate = 5 -> (BUSstate'=6); // DelayedCall change
	[change] BUSstate = 1 -> (BUSstate'=4); // Green change
	[change] BUSstate = 8 -> (BUSstate'=8); // CW : CW leave green

	[delayedPedCall] true -> (BUSpedc'=true);
	[pedCall] CWstate = 0 & !CWjustCalled & !CWbusc -> (BUSpedc'=true);
	[pedCall] CWstate = 0 & CWbusc -> (BUSpedc'=true) & (BUSpreemptible'=false);
	[pedCall] CWstate != 0-> (BUSpedc'=true);

	[delayedBusCall] BUSstate=0 & BUSpreemptible & BUSjustCalled -> 1/BUStime : (BUSstate'=5) & (BUSbusc'=true);
	[busCall] BUSstate=0 & BUSpreemptible & !BUSjustCalled -> 1/BUStime : (BUSstate'=2) & (BUSbusc'=true); // Red buscall
	[busCall] BUSstate=0 & !BUSpreemptible -> 1/BUStime : (BUSstate'=7) & (BUSbusc'=true); // Red buscall
	[busCall] BUSstate=6 & BUSpreemptible -> (BUSstate'=2); // Return busscall
	[busCall] BUSstate=3 -> (BUSstate'=1); // Waiting busscall

	[busPreempt] BUSstate=6 & !BUSpreemptible -> (BUSstate'=7); // Return preempt

	[free] BUSstate=7 -> (BUSstate'=1); // Preempted free
	[free] BUSstate=4 & !BUSpedc -> (BUSstate'=0) & (BUSbusc'=false) & (BUSjustCalled'=true); // Free free
	[free] BUSstate=4 & BUSpedc -> (BUSstate'=8) & (BUSbusc'=false); // Free free
	[free] BUSstate=8 -> (BUSstate'=0) & (BUSjustCalled'=true); // CW free
	[free] BUSstate=0 -> (BUSstate'=0); // Red free

	
endmodule

rewards "CWgreen"
	[pedCall] CWstate = 3 : 1; // Waiting to green
	[free] CWstate = 7 : 1; // Preempted to green
endrewards

rewards "LRgreen"
	[change] LRcolor = 0 : 1; // Red to green
	[free] LRcolor = 2 & !LRbusc & !LRprec : 1; // CW free to green
	[free] LRcolor = 3 & !LRpedc & !LRprec : 1; // Bus free to green
endrewards

rewards "FBgreen"
	[change] FBcolor = 0 : 1; // Red to green
	[free] FBcolor = 2 & !FBbusc & !FBprec : 1; // CW free to green
	[free] FBcolor = 3 & !FBpedc & !FBprec : 1; // Bus free to green
endrewards

rewards "BUSgreen"
	[busCall] BUSstate=3 : 1; // Waiting to green
	[free] BUSstate=7 : 1; // Preempted to green
endrewards
